{
  "version": 3,
  "sources": ["../../@lexical/react/LexicalComposer.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { createLexicalComposerContext, LexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { createEditor, $getRoot, $createParagraphNode, $getSelection } from 'lexical';\nimport * as React from 'react';\nimport { useLayoutEffect, useEffect, useMemo } from 'react';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst useLayoutEffectImpl = CAN_USE_DOM ? useLayoutEffect : useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE_OPTIONS = {\n  tag: 'history-merge'\n};\nfunction LexicalComposer({\n  initialConfig,\n  children\n}) {\n  const composerContext = useMemo(() => {\n    const {\n      theme,\n      namespace,\n      editor__DEPRECATED: initialEditor,\n      nodes,\n      onError,\n      editorState: initialEditorState,\n      html\n    } = initialConfig;\n    const context = createLexicalComposerContext(null, theme);\n    let editor = initialEditor || null;\n    if (editor === null) {\n      const newEditor = createEditor({\n        editable: initialConfig.editable,\n        html,\n        namespace,\n        nodes,\n        onError: error => onError(error, newEditor),\n        theme\n      });\n      initializeEditor(newEditor, initialEditorState);\n      editor = newEditor;\n    }\n    return [editor, context];\n  },\n  // We only do this for init\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useLayoutEffectImpl(() => {\n    const isEditable = initialConfig.editable;\n    const [editor] = composerContext;\n    editor.setEditable(isEditable !== undefined ? isEditable : true);\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/React.createElement(LexicalComposerContext.Provider, {\n    value: composerContext\n  }, children);\n}\nfunction initializeEditor(editor, initialEditorState) {\n  if (initialEditorState === null) {\n    return;\n  } else if (initialEditorState === undefined) {\n    editor.update(() => {\n      const root = $getRoot();\n      if (root.isEmpty()) {\n        const paragraph = $createParagraphNode();\n        root.append(paragraph);\n        const activeElement = CAN_USE_DOM ? document.activeElement : null;\n        if ($getSelection() !== null || activeElement !== null && activeElement === editor.getRootElement()) {\n          paragraph.select();\n        }\n      }\n    }, HISTORY_MERGE_OPTIONS);\n  } else if (initialEditorState !== null) {\n    switch (typeof initialEditorState) {\n      case 'string':\n        {\n          const parsedEditorState = editor.parseEditorState(initialEditorState);\n          editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'object':\n        {\n          editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'function':\n        {\n          editor.update(() => {\n            const root = $getRoot();\n            if (root.isEmpty()) {\n              initialEditorState(editor);\n            }\n          }, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n    }\n  }\n}\n\nexport { LexicalComposer };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAUA,YAAuB;AACvB,mBAAoD;AAUpD,IAAM,cAAc,OAAO,WAAW,eAAe,OAAO,OAAO,aAAa,eAAe,OAAO,OAAO,SAAS,kBAAkB;AAUxI,IAAM,sBAAsB,cAAc,+BAAkB;AAU5D,IAAM,wBAAwB;AAAA,EAC5B,KAAK;AACP;AACA,SAAS,gBAAgB;AAAA,EACvB;AAAA,EACA;AACF,GAAG;AACD,QAAM,sBAAkB;AAAA,IAAQ,MAAM;AACpC,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,QACA,oBAAoB;AAAA,QACpB;AAAA,QACA;AAAA,QACA,aAAa;AAAA,QACb;AAAA,MACF,IAAI;AACJ,YAAM,UAAU,6BAA6B,MAAM,KAAK;AACxD,UAAI,SAAS,iBAAiB;AAC9B,UAAI,WAAW,MAAM;AACnB,cAAM,YAAY,aAAa;AAAA,UAC7B,UAAU,cAAc;AAAA,UACxB;AAAA,UACA;AAAA,UACA;AAAA,UACA,SAAS,WAAS,QAAQ,OAAO,SAAS;AAAA,UAC1C;AAAA,QACF,CAAC;AACD,yBAAiB,WAAW,kBAAkB;AAC9C,iBAAS;AAAA,MACX;AACA,aAAO,CAAC,QAAQ,OAAO;AAAA,IACzB;AAAA;AAAA;AAAA,IAGA,CAAC;AAAA,EAAC;AACF,sBAAoB,MAAM;AACxB,UAAM,aAAa,cAAc;AACjC,UAAM,CAAC,MAAM,IAAI;AACjB,WAAO,YAAY,eAAe,SAAY,aAAa,IAAI;AAAA,EAIjE,GAAG,CAAC,CAAC;AACL,SAA0B,oBAAc,uBAAuB,UAAU;AAAA,IACvE,OAAO;AAAA,EACT,GAAG,QAAQ;AACb;AACA,SAAS,iBAAiB,QAAQ,oBAAoB;AACpD,MAAI,uBAAuB,MAAM;AAC/B;AAAA,EACF,WAAW,uBAAuB,QAAW;AAC3C,WAAO,OAAO,MAAM;AAClB,YAAM,OAAO,SAAS;AACtB,UAAI,KAAK,QAAQ,GAAG;AAClB,cAAM,YAAY,qBAAqB;AACvC,aAAK,OAAO,SAAS;AACrB,cAAM,gBAAgB,cAAc,SAAS,gBAAgB;AAC7D,YAAI,cAAc,MAAM,QAAQ,kBAAkB,QAAQ,kBAAkB,OAAO,eAAe,GAAG;AACnG,oBAAU,OAAO;AAAA,QACnB;AAAA,MACF;AAAA,IACF,GAAG,qBAAqB;AAAA,EAC1B,WAAW,uBAAuB,MAAM;AACtC,YAAQ,OAAO,oBAAoB;AAAA,MACjC,KAAK,UACH;AACE,cAAM,oBAAoB,OAAO,iBAAiB,kBAAkB;AACpE,eAAO,eAAe,mBAAmB,qBAAqB;AAC9D;AAAA,MACF;AAAA,MACF,KAAK,UACH;AACE,eAAO,eAAe,oBAAoB,qBAAqB;AAC/D;AAAA,MACF;AAAA,MACF,KAAK,YACH;AACE,eAAO,OAAO,MAAM;AAClB,gBAAM,OAAO,SAAS;AACtB,cAAI,KAAK,QAAQ,GAAG;AAClB,+BAAmB,MAAM;AAAA,UAC3B;AAAA,QACF,GAAG,qBAAqB;AACxB;AAAA,MACF;AAAA,IACJ;AAAA,EACF;AACF;",
  "names": []
}
