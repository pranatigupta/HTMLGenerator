{
  "version": 3,
  "sources": ["../../@lexical/utils/LexicalUtils.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { createRectsFromDOMRange, $cloneWithProperties } from '@lexical/selection';\nimport { $getSelection, $isRangeSelection, TextNode, $getRoot, $isElementNode, $isTextNode, $setSelection, $getPreviousSelection, $isRootOrShadowRoot, $splitNode, $createParagraphNode } from 'lexical';\nexport { $splitNode, isBlockDomNode, isHTMLAnchorElement, isHTMLElement, isInlineDomNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguements\n * are considered to be the func argument and spread from there.\n * @param func - An array of functions meant to be executed by the returned function.\n * @returns the function which executes all the passed register command functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    func.forEach(f => f());\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction positionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      throw Error(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      throw Error(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: rootLeft,\n      top: rootTop\n    } = rootDOMNode.getBoundingClientRect();\n    const parentDOMNode_ = parentDOMNode;\n    const rects = createRectsFromDOMRange(editor, range);\n    if (!wrapperNode.isConnected) {\n      parentDOMNode_.append(wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - rootLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - rootTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(currentParentDOMNode instanceof HTMLElement)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM === null || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey() || currentAnchorNode !== previousAnchorNode && (!(previousAnchorNode instanceof TextNode) || currentAnchorNode.updateDOM(previousAnchorNode, currentAnchorNodeDOM, editor._config));\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM === null || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey() || currentFocusNode !== previousFocusNode && (!(previousFocusNode instanceof TextNode) || currentFocusNode.updateDOM(previousFocusNode, currentFocusNodeDOM, editor._config));\n      if (differentAnchorDOM || differentFocusDOM) {\n        const anchorHTMLElement = editor.getElementByKey(anchor.getNode().getKey());\n        const focusHTMLElement = editor.getElementByKey(focus.getNode().getKey());\n        // TODO handle selection beyond the common TextNode\n        if (anchorHTMLElement !== null && focusHTMLElement !== null && anchorHTMLElement.tagName === 'SPAN' && focusHTMLElement.tagName === 'SPAN') {\n          const range = document.createRange();\n          let firstHTMLElement;\n          let firstOffset;\n          let lastHTMLElement;\n          let lastOffset;\n          if (focus.isBefore(anchor)) {\n            firstHTMLElement = focusHTMLElement;\n            firstOffset = focus.offset;\n            lastHTMLElement = anchorHTMLElement;\n            lastOffset = anchor.offset;\n          } else {\n            firstHTMLElement = anchorHTMLElement;\n            firstOffset = anchor.offset;\n            lastHTMLElement = focusHTMLElement;\n            lastOffset = focus.offset;\n          }\n          const firstTextNode = firstHTMLElement.firstChild;\n          if (!(firstTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          const lastTextNode = lastHTMLElement.firstChild;\n          if (!(lastTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          range.setStart(firstTextNode, firstOffset);\n          range.setEnd(lastTextNode, lastOffset);\n          removeRangeListener();\n          removeRangeListener = positionNodeOnRange(editor, range, domNodes => {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.zIndex !== '-1') {\n                domNodeStyle.zIndex = '-1';\n              }\n              if (domNodeStyle.pointerEvents !== 'none') {\n                domNodeStyle.pointerEvents = 'none';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n            if (onReposition !== undefined) {\n              onReposition(domNodes);\n            }\n          });\n        }\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), removeRangeListener, () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\n *   src: file.result,\n * }));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startingNode - The node to start the search, if ommitted, it will start at the root node.\n * @param endingNode - The node to end the search, if ommitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * {depth: number, node: LexicalNode} It will always return at least 1 node (the ending node) so long as it exists\n */\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || $getRoot()).getLatest();\n  const end = endingNode || ($isElementNode(start) ? start.getLastDescendant() || start : start);\n  let node = start;\n  let depth = $getDepth(node);\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n    if ($isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n  return nodes;\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to paret and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  let node = startingNode;\n  if ($isElementNode(node) && node.getChildrenSize() > 0) {\n    node = node.getLastChild();\n  } else {\n    let sibling = null;\n    while (sibling === null && node !== null) {\n      sibling = node.getPreviousSibling();\n      if (sibling === null) {\n        node = node.getParent();\n      } else {\n        node = sibling;\n      }\n    }\n  }\n  return node;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => $isElementNode(node) && !node.isInline());\n  if (!$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = $cloneWithProperties(node);\n    if ($isTextNode(clone)) {\n      if (!$isTextNode(node)) {\n        throw Error(`Expected node be a TextNode`);\n      }\n      clone.__text = node.__text;\n    }\n    nodeMap.set(key, clone);\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  $setSelection(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = $getSelection() || $getPreviousSelection();\n  if ($isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if ($isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if ($isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = $splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = $getRoot();\n      root.append(node);\n    }\n    const paragraphNode = $createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  if (IS_FIREFOX) {\n    return 1;\n  }\n  let zoom = 1;\n  while (element) {\n    zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n    element = element.parentElement;\n  }\n  return zoom;\n}\n\nexport { $dfs, $filter, $findMatchingParent, $getNearestBlockElementAncestorOrThrow, $getNearestNodeOfType, $getNextRightPreorderNode, $insertFirst, $insertNodeToNearestRoot, $restoreEditorState, $wrapNodeInElement, CAN_USE_BEFORE_INPUT, CAN_USE_DOM, IS_ANDROID, IS_ANDROID_CHROME, IS_APPLE, IS_APPLE_WEBKIT, IS_CHROME, IS_FIREFOX, IS_IOS, IS_SAFARI, addClassNamesToElement, calculateZoomLevel, isMimeType, markSelection, mediaFileReader, mergeRegister, objectKlassEquals, positionNodeOnRange, registerNestedElementResolver, removeClassNamesFromElement };\n"],
  "mappings": "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",
  "names": []
}
